主题: SIP学习摘要 -

# 对话、事务、消息

在SIP中，对话 (Dialog)、事务 (Transaction) 和 消息 (Message) 是三个核心的、有层级关系的概念。我们可以把它们想象成一套俄罗斯套娃：

对话 (Dialog) 是最大的那个娃娃，代表整个通话。
事务 (Transaction) 是中间的娃娃，代表一次完整的“请求-响应”交互。
消息 (Message) 是最小的娃娃，代表网络上传输的单个数据包。
一个“对话”由多个“事务”组成，一个“事务”又由多条“消息”组成。

让我们来逐一拆解：

1. 对话 (Dialog) - 整个通话的生命周期
是什么？ “对话”是两个SIP终端之间的一个完整的、持续的关系。它代表了从通话被接通那一刻起，到最终被挂断的整个过程。
如何创建？ 一个成功的INVITE事务（具体来说，是INVITE请求收到了2xx成功响应后）会创建一个对话。
如何识别？ 这是关键！对话由一个全局唯一的“三件套”来标识：
Call-ID (呼叫ID)
From头的tag (主叫方标签)
To头的tag (被叫方标签) 只要这三者组合在一起，就能在全世界唯一确定一个SIP对话。
如何结束？ 一个成功的BYE事务会终结这个对话。
类比: 如果把通话比作一次“项目合作”，那么“对话”就是这个项目的整个生命周期，从合同签订到项目结束。
2. 事务 (Transaction) - 一次完整的“你问我答”
是什么？ “事务”是SIP中一个基本的请求-响应交换单元。它包含了从客户端发出一个请求，到它收到一个最终响应（非1xx的响应）为止的所有消息。
生命周期: 事务的生命周期由定时器控制（就是我们刚讨论的超时机制）。一旦事务完成（收到最终响应或超时），它就结束了。事务是短暂的，而对话是持续的。
如何识别？ 事务通过其CSeq头中的序列号和方法名，以及Via头中的branch参数来识别。
事务的种类:
INVITE事务: 特殊且复杂，因为它涉及1xx临时响应和ACK确认，并且它负责创建“对话”。
非INVITE事务: 相对简单，比如BYE、REGISTER、MESSAGE等，通常只有“请求-最终响应”两步。
类比: 在“项目合作”（对话）中，“事务”就是一次具体的任务，比如“发出合同并等待对方签字返回”这一个完整的动作。
3. 消息 (Message) - 最基本的通信“砖块”
是什么？ “消息”是SIP通信中最基本的单位，就是指一个在网络上传输的、遵循SIP格式的数据包。
消息的种类:
请求 (Request): 由客户端发起，用来请求某个动作。例如: INVITE, BYE, ACK, CANCEL, REGISTER。
响应 (Response): 由服务器发出，用来回应一个请求。例如: 100 Trying, 180 Ringing, 200 OK, 404 Not Found。
类比: 在“发出合同并等待签字返回”（事务）这个任务中，“消息”就是你发出的那封“内含合同的电子邮件”，以及对方回复的那封“内含已签字合同的电子邮件”。
总结与层级图
我们可以用一个简单的结构图来清晰地展示它们的关系：

对话 (Dialog)  <-- 整个电话通话
|
├─ 事务 (Transaction 1: 建立通话)
|  ├─ 消息 (Message: INVITE 请求)
|  ├─ 消息 (Message: 180 Ringing 响应)
|  ├─ 消息 (Message: 200 OK 响应)
|  └─ 消息 (Message: ACK 请求)
|
├─ 事务 (Transaction 2: 通话保持)
|  ├─ 消息 (Message: re-INVITE 请求)
|  ├─ 消息 (Message: 200 OK 响应)
|  └─ 消息 (Message: ACK 请求)
|
└─ 事务 (Transaction 3: 结束通话)
   ├─ 消息 (Message: BYE 请求)
   └─ 消息 (Message: 200 OK 响应)
理解了这三个层次，你就掌握了阅读和分析SIP信令流程图的钥匙。任何复杂的SIP通话，都可以被拆解成这三个层次来进行分析。

# PUBLIC SUBSCRIBE NOTIFY MESSAGE

SIMPLE中我们讨论的那些核心动作——PUBLISH、SUBSCRIBE、NOTIFY以及发送即时消息的MESSAGE——在SIP的层级模型中，每一个都是一个独立的事务 (Transaction)。

你已经掌握了精髓：只要是一次“请求-响应”的完整交换，它就是一个事务。

我们来具体看看它们分别是什么样的事务：

1. SUBSCRIBE (订阅) 事务
是什么？ 这是一个由观察者(Watcher)发起的非INVITE事务。
流程:
请求: 观察者发送 SUBSCRIBE 请求，希望能订阅某个人的状态。
响应: 状态代理服务器(Presence Agent)回复 200 OK，表示“好的，你的订阅请求我已接受”。
特殊性: 这个事务成功后，会在服务器上创建一个长期的“订阅关系”。这个订阅关系本身，也可以被看作是一种广义上的对话(Dialog)，因为它也有生命周期（会过期），并且后续的NOTIFY都与它关联。
2. PUBLISH (发布) 事务
是什么？ 这是一个由被呈现实体(Presentity)发起的非INVITE事务。
流程:
请求: 你的客户端发送 PUBLISH 请求，把你“在线”的状态发布给服务器。
响应: 服务器回复 200 OK，表示“好的，你的新状态我已收到并更新”。
特点: 这是一个独立的、一次性的事务。
3. NOTIFY (通知) 事务
是什么？ 这是最特别的一个！NOTIFY本身是一个请求，而不是响应。它是一个由服务器主动发起的非INVITE事务。
流程:
请求: 状态代理服务器向所有订阅者发送 NOTIFY 请求，内容是“XX的状态更新为‘忙碌’了”。
响应: 订阅者的客户端收到后，必须回复一个 200 OK，以告知服务器“我已收到这条通知”。
重要性: NOTIFY必须得到200 OK的确认，这保证了状态通知是可靠的。如果服务器没收到OK，它会重传NOTIFY。
4. MESSAGE (即时消息) 事务
是什么？ 这是一个由消息发送方发起的非INVITE事务。
流程:
请求: A发送 MESSAGE 请求，内容是“你好”。
响应: B回复 200 OK，表示“消息已送达”。
将它们放入层级模型中
以一个完整的“订阅-通知”流程为例，我们可以清晰地看到事务是如何构成一个对话（订阅关系）的：

订阅对话 (Subscription Dialog) <-- 订阅者与服务器之间的长期关系
|
├─ 事务 1: 订阅 (SUBSCRIBE Transaction)
|  ├─ 消息 (Message: SUBSCRIBE Request)
|  └─ 消息 (Message: 200 OK Response)
|
├─ 事务 2: 首次状态通知 (First NOTIFY Transaction)
|  ├─ 消息 (Message: NOTIFY Request)
|  └─ 消息 (Message: 200 OK Response)
|
└─ 事务 3: 后续状态更新通知 (Later NOTIFY Transaction)
   ├─ 消息 (Message: NOTIFY Request)
   └─ 消息 (Message: 200 OK Response)


# 对话ID (以Call-ID为核心) 与 事务ID (以branch为核心) 的对比

为清晰区分SIP协议中用于标识“对话(Dialog)”和“事务(Transaction)”的两种核心机制，特此总结，以便快速查阅和理解。

核心对比表
| 特性 | 对话ID (Dialog Identifier) | 事务ID (Transaction Identifier) |
| :--- | :--- | :--- |
| **核心用途** | 关联一次**完整通话**中的所有交互（从接通到挂断）。 | 精确匹配一次“**请求-响应**”的交换过程。 |
| **一句话类比** | 通话的“**档案号**”或“**项目编号**”。 | 每次请求-应答的“**流水号**”或“**快递单号**”。 |
| **具体构成** | **“三件套”：**<br>1. `Call-ID` 头<br>2. `From` 头的 `tag` 参数<br>3. `To` 头的 `tag` 参数 | **“事实上的ID”：**<br>最顶部`Via`头中的`branch`参数（通常以`z9hG4bK`开头）。 |
| **生命周期** | **长期 (Long-lived)**<br>与通话共存亡，从成功的`INVITE`事务开始，到`BYE`事务结束。 | **短暂 (Short-lived)**<br>由定时器控制，从发出请求开始，到收到最终响应或超时后结束。 |
| **解决的问题** | “如何确定`BYE`请求是用来结束哪个通话的？” | “如何将收到的`200 OK`响应准确地匹配到我几秒前发出的那个`INVITE`请求上？” |

导出到 Google 表格
核心要点总结
层级关系：对话是更高一级的概念，它由一个或多个事务组成。对话ID是宏观的，事务ID是微观的。

身份与动作：对话ID标识的是一个长期的“关系”或“身份”；而事务ID (branch)标识的是一个短暂的“动作”或“过程”。

协同工作: 在一次通话中，Call-ID保持不变，而每次新的交互（如re-INVITE, BYE）都会生成一个新的、唯一的branch参数。正是通过不变的对话ID和变化的事务ID，SIP才能将一次次短暂的交互，有条不紊地组织成一次完整的通话。

简单来说，如果一次完整的通话是一个项目档案，那么对话ID就是这个档案的唯一档案号。而事务ID (branch)则是这份档案中每一次“请示-批复”往来文件的唯一流水号。

一个管长期关系，一个管即时交互。两者协同工作，构成了SIP可靠通信的基石。

# 方法

“方法”是所有SIP请求消息 (Request) 的核心，它永远出现在请求消息的第一行（Request-Line）的第一个位置。例如：
INVITE sip:bob@example.com SIP/2.0

这些方法就像一个工具箱，每个工具都有专门的用途。我们可以把它们分为两大类：基础方法 和 扩展方法。

1. 基础方法 (在核心RFC 3261中定义)
这些是SIP诞生之初就有的最核心的“工具”。

INVITE: 邀请。这是最重要、最复杂的方法，用于邀请一个用户或设备加入一个会话（比如通话或会议）。
ACK: 确认。这个方法很特别，它只用于对INVITE请求的最终成功响应（2xx） 进行确认，完成“三次握手”，表示通话已牢固建立。
BYE: 再见。用于终止一个已经建立的通话。也就是我们常说的“挂断电话”。
CANCEL: 取消。用于取消一个还未最终响应的请求。它和BYE的区别是：CANCEL用在你拨打电话但对方还没接听时就挂断；而BYE用在双方通话之后再挂断。
REGISTER: 注册。用于客户端（比如你的IP电话或手机App）向注册服务器(Registrar)报告自己的当前位置（IP地址），就像酒店前台“签到”一样。
OPTIONS: 选项。用于查询远端服务器或客户端的能力信息（比如支持哪些方法、哪些编解码器），但并不会建立通话。就像在打电话前，先问一句“你都会些什么？”。
2. 扩展方法 (在后续的RFC中为增加新功能而定义)
随着技术发展，SIP通过增加新的方法来支持更多功能，我们昨天学习的SIMPLE框架就主要依赖于这些扩展方法。

SUBSCRIBE: 订阅。用于向服务器订阅某个事件或状态的更新。例如，“我想订阅小红的在线状态”。
NOTIFY: 通知。这是一个由服务器主动发起的请求，用于向所有订阅者推送最新的状态通知。例如，“小红的状态已更新为‘忙碌’”。
PUBLISH: 发布。用于客户端向服务器发布自己的状态信息。例如，“我现在的状态是‘在线’”。
MESSAGE: 消息。用于发送一个即时消息（短消息），采用“寻呼模式”，发送一次即完成。
REFER: 引荐/转移。用于请求接收方去联系一个第三方。这个方法是实现“通话转移”功能的核心。就像在通话中对A说，“你去找C吧”，并把C的联系方式告诉A。
UPDATE: 更新。用于在会话建立的早期（在200 OK响应发出前）修改会话参数，比如更新媒体信息。
| 方法 (Method) | 主要用途 | 备注 |
| :--- | :--- | :--- |
| `INVITE` | 邀请用户加入会话（通话） | 最核心、最复杂的方法 |
| `ACK` | 确认对`INVITE`的最终成功响应 | 对`INVITE`的“三次握手”至关重要 |
| `BYE` | 终止一个**已建立**的通话 | 挂断已接通的电话 |
| `CANCEL` | 取消一个**还未建立**的请求 | 在对方接听前就挂断 |
| `REGISTER` | 注册用户的位置信息 | 手机开机时的“签到” |
| `OPTIONS` | 查询对方的能力 | “你都会些什么？” |
| `SUBSCRIBE` | 订阅状态 | SIMPLE核心，“关注”好友 |
| `NOTIFY` | 发送状态通知 | SIMPLE核心，服务器主动推送 |
| `PUBLISH` | 发布自己的状态 | SIMPLE核心，“发动态” |
| `MESSAGE` | 发送即时消息 | 发短信/聊天 |
| `REFER` | 实现呼叫转移 | “你去找他吧” |

这个“方法(Method)”的集合，共同构成了SIP协议的“动作指令集”。正是通过组合使用这些方法，SIP才能实现从简单的电话到复杂的统一通信等各种功能。

# sip定时器

SIP经常运行在 UDP 协议之上，而UDP本身是不可靠的——它不保证消息一定能送达。那么，SIP是如何在这种不可靠的环境下，确保呼叫能够稳定建立或优雅失败的呢？

答案就是一套精心设计的超时与重传机制，这套机制由一系列“定时器 (Timers)”来控制。我们不必记住所有定时器的名字（比如Timer A, B, F...），但理解它们的工作原理非常重要。

核心机制：指数退避重传 (Exponential Backoff)
这是SIP超时处理的基石。当客户端发送一个请求后，它会这样做：

启动一个初始定时器 T1（默认值通常是 500毫秒）。
如果在T1时间内没有收到任何回应，它会重新发送一次请求，并将下一个等待时间设置为 2*T1。
如果还没收到回应，它会再次重传，并将等待时间加倍到 4*T1。
这个过程会一直持续，直到达到一个“放弃”的总时限，宣告事务失败。
这种“指数级增加等待时间”的策略，既能努力保证消息送达，又能避免在网络拥堵时疯狂重传导致雪上加霜。

场景一：INVITE 请求的超时处理 (最复杂的场景)
INVITE 请求是建立通话的第一步，它的超时处理也最严谨。

1. 客户端（主叫方）的操作：

发送INVITE: 主叫方发送INVITE后，会启动两个关键定时器。

重传定时器 (Timer A): 初始值为T1 (500ms)。如果T1超时，就重发INVITE，并将下一个重传定时器设为2*T1。
事务超时定时器 (Timer B): 这是“放弃”定时器，总时长为 64*T1（即 32秒）。如果在这个时间内，主叫方没有收到任何最终响应（如200 OK或404 Not Found），它就会彻底放弃这次呼叫，并在界面上显示“呼叫失败”或“请求超时”。
如何停止重传？
只要主叫方收到了任何来自服务端的响应，即使只是一个临时的100 Trying，它都会停止重传INVITE。这就是为什么服务器在收到INVITE后，应该尽快回复100 Trying的原因——它能有效安抚客户端，防止不必要的重传。

2. 200 OK 响应丢失了怎么办？
这是INVITE事务的特殊之处。假设被叫方已经接听并发送了200 OK，但这个200 OK在网络中丢失了。

被叫方会重传200 OK: 被叫方发送200 OK后，会启动自己的定时器。如果迟迟收不到主叫方的ACK确认消息，它会认为200 OK丢失了，于是会周期性地重传200 OK。
主叫方收到后发送ACK: 当主叫方最终收到了这个（可能是重传的）200 OK后，它会立刻发送ACK。这个ACK就是告诉对方：“我收到你的OK了，别再重传了！”
如果ACK也丢失了呢？: 被叫方没收到ACK，会继续重传200 OK。主叫方再次收到重复的200 OK时，会意识到自己的ACK可能丢了，于是会再次发送ACK。这个机制保证了双方最终能就“通话已建立”这个事实达成一致。
场景二：非 INVITE 请求的超时处理 (如 BYE, MESSAGE)
对于BYE或MESSAGE这些比较简单的请求，流程也相对简单，因为它们是“请求-响应”两步，不像INVITE需要ACK进行第三步确认。

客户端操作: 客户端发送请求（如BYE）后，会启动一个初始为T1的重传定时器。
超时放弃: 如果在总共64*T1（32秒）内没有收到任何最终响应，客户端就认为该事务失败。例如，如果发送BYE后一直没收到200 OK，32秒后主叫方也会单方面认为通话已结束，并清除会话信息。
总结
| 定时器类型 | 默认值 | 作用 |
| :--- | :--- | :--- |
| **T1** | 500毫秒 | 所有重传计时器的基础单位。 |
| **Timer B** | 32秒 (64*T1) | `INVITE`事务的“放弃”定时器。 |
| **Timer F** | 32秒 (64*T1) | 非`INVITE`事务的“放弃”定时器。 |

导出到 Google 表格
SIP的超时处理机制是其在不可靠的UDP网络上实现可靠通信的基石。它通过一套严谨的重传与放弃逻辑，确保了任何一个请求要么最终成功，要么在可预知的时间内优雅地失败，避免了无限期的“僵尸会话”。


# SIMPLE框架:消息、文本、短音频/视频;发布订阅通知

此备忘录旨在总结回顾关于SIP协议的学习要点，特别是其强大的扩展框架SIMPLE，它将SIP的应用从语音通话扩展到了现代即时通讯领域。

1. SIMPLE框架核心概述
全称: SIP for Instant Messaging and Presence Leveraging Extensions。
本质: 它不是一个新协议，而是利用SIP现有架构（如代理服务器、注册服务器）的一套扩展和规范。
两大支柱:
状态呈现 (Presence): 让用户能发布并订阅他人的实时状态（如在线、忙碌、离开）。
即时消息 (Instant Messaging): 实现类似短信和聊天的功能。
2. 核心功能一：状态呈现 (Presence) - “你的好友在线吗？”
实现模型: 基于经典的“发布/订阅 (Publish/Subscribe)”模型。
关键SIP方法:
PUBLISH: 用户客户端使用此方法向服务器“发布”自己的当前状态。
SUBSCRIBE: 用户客户端使用此方法向服务器“订阅”好友的状态更新。
NOTIFY: 服务器在收到订阅后，以及每当好友状态变化时，使用此方法主动“通知”订阅者。
工作方式: 可理解为一个动态的“好友状态公告板”，服务器是公告板，用户既是信息发布者也是订阅者。
3. 核心功能二：即时消息 (IM) 与高级功能
3.1. 发送文本消息

实现方法: 使用 MESSAGE 方法，而非INVITE。
工作模式: “寻呼模式”（Sessionless），即发即到，是一次性的交互，无需BYE来结束。
基本流程: A发送MESSAGE -> B收到后回复200 OK（表示已送达），交互完成。
3.2. 实现“已读回执” (关键点)

基础: 仅靠200 OK无法实现“已读”，它只代表“已送达”到设备。
实现标准: 需遵循 RFC 5438 (IMDN) 规范，一个需要双方客户端都支持的扩展功能。
实现流程:
请求: A在发送MESSAGE时，需额外加入IM-Notification头字段，明确要求“显示后通知我”。
通知: 当B的用户真正阅读消息后，B的客户端会构造一个全新的MESSAGE请求发送给A。
回执内容: 这个新MESSAGE的内容是一个特定格式的XML文件，其中包含<display/>标签，这才是“已读”的真正标志。
3.3. 发送短语音/文件 (关键点)

核心原则: 信令与媒体分离 (Separation of Signaling and Media)。
错误方式: 不应将音频或文件等“重”数据直接放入MESSAGE的消息体中，这会因大小限制和效率低下而导致失败。
标准方式:
客户端先将语音/文件通过 HTTP/S协议 上传至专用的媒体服务器 (Media Server)。
媒体服务器返回一个该文件的专属URL链接。
客户端通过SIP的MESSAGE方法，将这个URL作为文本发送给对方。
接收方客户端再通过HTTP/S从该URL下载或播放文件。
类比: 这就像发送“云盘分享链接”，而不是尝试把整个文件塞进短信里。
总结: SIMPLE框架通过巧妙的扩展，将SIP从一个呼叫控制协议转变为一个全功能的统一通信（UC）信令基石。其设计的精髓在于利用SIP作为灵活的信令框架，同时通过各种扩展（如IMDN）和与其他协议（如HTTP）的结合，实现了状态、即时消息、文件传输等丰富功能。

## SIP代理(Proxy Server)和背靠背代理(B2BUA)

一个“SIP 服务器”实际上是一个通用的术语，它可以扮演多种角色。根据 RFC 3261 的定义，一个 SIP 网络实体可以是一个或多个角色的组合。您的问题触及了 SIP 架构中最关键的一个选择：您的服务器应该作为 **SIP 代理（Proxy）** 还是作为 **背靠背用户代理（Back-to-Back User Agent, B2BUA）** 来工作。

---

### 1. SIP 代理 (Proxy Server) 的角色

SIP 代理服务器是 SIP 架构的“路由器”。它的主要职责是代表用户代理（UA，即 SIP 客户端）转发请求和响应。

#### 核心功能：
* **路由 (Routing)**: 代理服务器的核心任务是决定将收到的 SIP 请求发送到哪里。它会查询“位置服务”（通常由 SIP Registrar 注册服务提供）来找到目标用户的当前 IP 地址和端口。
* **策略执行 (Policy Enforcement)**: 可以在代理上实施简单的策略，例如检查用户是否被授权拨打电话、是否允许呼叫特定号码等。
* **修改消息 (Message Modification)**: 代理服务器在转发消息时，必须添加自己的 `Via` 头部，以便响应能够沿着原路返回。它通常不会修改像 `From`, `To`, `Call-ID` 和消息体 (SDP) 这样的核心头部。
* **状态管理**:
    * **无状态代理 (Stateless Proxy)**: 完全不维护任何“事务”或“对话”的状态。它只是简单地转发消息，性能极高，但功能有限。
    * **有状态代理 (Stateful Proxy)**: 维护 SIP“事务”的状态（即请求和响应的匹配关系）。这使得它可以处理重传、分叉（forking，将一个 INVITE 请求同时发送给多个终端）等高级路由功能。这是最常见的代理模式。

**从您的 `sofia-sip` 源代码来看，它完全有能力实现一个高性能的有状态代理。**
* `sofia-sip/libsofia-sip-ua/nta/`: 这个目录下的 `nta` (Network Transaction Agent) 就是实现 SIP 事务层状态机的核心，这是有状态代理的基础。
* `sofia-sip/sofia-sip/tests/test_proxy.c`: 这个文件是一个明确的例子，展示了如何使用 `sofia-sip` 库来构建一个 SIP 代理。

---

### 2. 背靠背用户代理 (B2BUA) 的角色

很多商业 SIP 系统，如 SBC（Session Border Controller）、IP-PBX 或呼叫中心平台，并不仅仅是代理，它们是 B2BUA。

B2BUA 表现为两个“背靠背”的用户代理。它从一方接收呼叫，然后作为客户端，向另一方发起一个全新的呼叫。它在两个呼叫腿（Call Leg）之间维持着完整的对话状态。

#### 核心功能：
* **完全的呼叫控制**: B2BUA 是呼叫信令的终点。它可以修改 SIP 消息的任何部分，包括 SDP（媒体描述），从而实现媒体流的控制。
* **媒体处理 (Media Anchoring)**: B2BUA 可以让媒体流（RTP）也流经自己，从而实现媒体转码（如 G.711 转 G.729）、通话录音、DTMF 信号处理等。
* **拓扑隐藏和安全**: 对外隐藏内部网络的拓扑结构，因为外部世界只看到 B2BUA 的地址。
* **协议转换**: 例如，在 WebRTC (WSS/SRTP) 和传统 SIP (UDP/RTP) 之间进行转换。


### 对比与决策

这是一个关键的架构决策点，您的选择取决于您的业务需求。

| 特性 | SIP 代理 (Proxy) | 背靠背用户代理 (B2BUA) |
| :--- | :--- | :--- |
| **核心功能** | 路由信令 | 控制信令和媒体 |
| **状态管理** | 事务状态 (Transaction Stateful) | 对话状态 (Dialog Stateful) |
| **消息处理** | 转发消息，仅修改路由相关的头部（如 `Via`） | 终止并重新生成消息，可修改任何部分 |
| **SDP/媒体处理** | 不关心 SDP 内容，媒体直通 (end-to-end) | 完全控制 SDP，媒体可以流经 B2BUA |
| **性能** | 非常高，延迟低，可扩展性强 | 资源消耗大，延迟较高，状态复杂 |
| **功能丰富度** | 专注于路由和位置服务 | 可实现丰富的增值业务（转码、录音、计费等） |
| **典型应用** | SIP 路由服务器、负载均衡器 | SBC, IP-PBX, 呼叫中心, WebRTC 网关 |

### 结论

**您的 SIP 服务器不仅适合增加代理服务，这很可能就是它的核心使命。**

您需要思考的是：

1.  **我只需要路由吗？** 如果您的服务器只需要根据地址进行高效的请求转发，并且不需要干预通话内容，那么一个**有状态代理 (Stateful Proxy)** 是最佳选择。它性能高、扩展性好。

2.  **我需要高级呼叫控制或媒体处理吗？** 如果您需要实现如通话录音、转码、WebRTC 对接、复杂的计费逻辑或隐藏网络拓扑等功能，那么您需要将服务器实现为 **B2BUA**。

`sofia-sip` 是一个功能强大的底层库，它为您提供了构建这两种服务模式的全部工具。您可以根据业务需求，利用 `nta` 和 `nua` API 灵活地构建您的 SIP 服务器。

# SIP协议学习总备忘
日期: 2025年6月15日
主题: SIP协议从基础到高级应用全面回顾

此备忘录旨在系统性地总结SIP协议的核心概念、工作流程、关键机制及高级应用（如SIMPLE框架），作为一份完整的学习参考资料。

## 第一部分：SIP核心基础

1.1 什么是SIP？
全称: Session Initiation Protocol (会话发起协议)。
核心定位: 一个信令协议 (Signaling Protocol)。它的主要工作是建立、修改和终止网络会-话。
信令与媒体分离: 这是SIP最重要的设计原则。
* SIP 负责“发号施令”，如协商通话、挂断等控制信令。
* RTP (Real-time Transport Protocol) 负责传输实际的音视频数据流（媒体）。

1.2 SIP网络中的关键角色
* 用户代理 (User Agent - UA): 通话的终端，如IP电话、手机App、电脑软电话。
* 代理服务器 (Proxy Server): SIP网络的“交通警察”和路由中枢，负责接收、解析并转发SIP请求。
* 注册服务器 (Registrar Server): 用户的“地址簿”或“酒店前台”，处理REGISTER请求，记录用户当前的IP地址和联系方式。

1.3 基本通话流程
一个最简单的通话建立与结束流程如下：

* INVITE: 主叫方发起呼叫邀请。
* 180 Ringing: 被叫方设备响铃，并通知主叫方。
* 200 OK: 被叫方接听电话，表示同意通话。
* ACK: 主叫方确认收到200 OK，完成“三次握手”，通话正式建立。
* (双方通过RTP协议进行音视频通话)
* BYE: 任意一方挂断电话。
* 200 OK: 另一方确认收到BYE，通话结束。

## 第二部分：SIP结构化概念
2.1 层级模型：对话、事务与消息
SIP的信令结构如同套娃，分为三个层次：

* 对话 (Dialog): 最大的娃娃。代表整个通话的生命周期，从接通到挂断。由一个唯一的“对话ID”标识。
* 事务 (Transaction): 中间的娃娃。代表一次完整的“请求-响应”交换过程。生命周期由定时器控制。
* 消息 (Message): 最小的娃娃。代表单个SIP数据包，分为请求（如INVITE）和响应（如200 OK）。

2.2 核心标识符对比：对话ID vs 事务ID
这是理解SIP信令匹配的关键。

Markdown

| 特性 | 对话ID (Dialog Identifier) | 事务ID (Transaction Identifier) |
| :--- | :--- | :--- |
| **核心用途** | 关联一次**完整通话**中的所有交互（从接通到挂断）。 | 精确匹配一次“**请求-响应**”的交换过程。 |
| **一句话类比** | 通话的“**档案号**”或“**项目编号**”。 | 每次请求-应答的“**流水号**”或“**快递单号**”。 |
| **具体构成** | **“三件套”：**<br>1. `Call-ID` 头<br>2. `From` 头的 `tag` 参数<br>3. `To` 头的 `tag` 参数 | **“事实上的ID”：**<br>最顶部`Via`头中的`branch`参数（通常以`z9hG4bK`开头）。 |
| **生命周期** | **长期 (Long-lived)**<br>与通话共存亡，从成功的`INVITE`事务开始，到`BYE`事务结束。 | **短暂 (Short-lived)**<br>由定时器控制，从发出请求开始，到收到最终响应或超时后结束。 |
| **解决的问题** | “如何确定`BYE`请求是用来结束哪个通话的？” | “如何将收到的`200 OK`响应准确地匹配到我几秒前发出的那个`INVITE`请求上？” |
## 第三部分：SIP方法与响应代码

3.1 SIP方法 (Methods) - “指令集”
“方法”定义了SIP请求希望执行的动作。

Markdown

| 方法 (Method) | 主要用途 | 备注 |
| :--- | :--- | :--- |
| `INVITE` | 邀请用户加入会话（通话） | 最核心、最复杂的方法 |
| `ACK` | 确认对`INVITE`的最终成功响应 | 对`INVITE`的“三次握手”至关重要 |
| `BYE` | 终止一个**已建立**的通话 | 挂断已接通的电话 |
| `CANCEL` | 取消一个**还未建立**的请求 | 在对方接听前就挂断 |
| `REGISTER` | 注册用户的位置信息 | 手机开机时的“签到” |
| `OPTIONS` | 查询对方的能力 | “你都会些什么？” |
| `SUBSCRIBE` | 订阅状态 | SIMPLE核心，“关注”好友 |
| `NOTIFY` | 发送状态通知 | SIMPLE核心，服务器主动推送 |
| `PUBLISH` | 发布自己的状态 | SIMPLE核心，“发动态” |
| `MESSAGE` | 发送即时消息 | 发短信/聊天 |
| `REFER` | 实现呼叫转移 | “你去找他吧” |

3.2 响应代码 (Response Codes) - “状态语言”
* 1xx (临场响应): 正在处理，请稍候。如 180 Ringing。
* 2xx (成功响应): 请求已成功。如 200 OK。
* 3xx (重定向响应): 需要采取进一步动作。如 302 Moved Temporarily (用于呼叫转移)。
* 4xx (客户端错误): 请求有误。如 404 Not Found, 486 Busy Here。
* 5xx (服务器错误): 服务器处理请求失败。如 503 Service Unavailable。
* 6xx (全局错误): 明确的、全局性的失败。如 603 Decline (对方拒接)。

## 第四部分：可靠性与高级机制
4.1 超时与重传机制
由于SIP常用于不可靠的UDP，这套机制是其可靠性的基石。

核心策略: 指数退避重传。初次等待T1（500ms），后续等待时间加倍，直到总超时。
关键定时器:
Markdown

| 定时器类型 | 默认值 | 作用 |
| :--- | :--- | :--- |
| **T1** | 500毫秒 | 所有重传计时器的基础单位。 |
| **Timer B** | 32秒 (64*T1) | `INVITE`事务的“放弃”定时器。 |
| **Timer F** | 32秒 (64*T1) | 非`INVITE`事务的“放弃”定时器。 |

4.2 会话内协商：re-INVITE
在一个已建立的通话中，任何一方都可以通过发送re-INVITE请求来修改会话参数，如：

实现通话保持 (Call Hold)。
从语音通话升级到视频通话。
作为会话定时器（心跳）来保活通话。
## 第五部分：SIMPLE框架：即时消息与状态呈现
SIMPLE利用SIP的扩展，将其能力从通话扩展到完整的即时通讯。

5.1 状态呈现 (Presence)
* 模型: 发布/订阅 (Publish/Subscribe) 模型。
* 流程:
你用PUBLISH发布自己的状态（如“在线”）。
你的朋友用SUBSCRIBE订阅你的状态。
服务器用NOTIFY向你的朋友推送你的状态更新。

5.2 即时消息 (IM) 与高级功能
发送文本: 使用MESSAGE方法，它是一个无会话的“寻呼模式”请求。
* “已读回执”:
200 OK仅代表已送达。
“已读”功能需遵循**RFC 5438 (IMDN)**标准。
发送方在MESSAGE中加入IM-Notification头请求回执。
接收方在用户阅读后，发送一个携带<display/> XML内容的新MESSAGE作为已读通知。
* 发送短语音/文件:
核心原则: 信令与媒体分离。
标准做法: 先用HTTP/S将文件上传到媒体服务器，获取URL，再通过MESSAGE方法将URL发送给对方。

## 第六部分 为什么选择应该选择有状态的代理服务

一句话总结：有状态是指事务状态不是我之前理解的会话状态

6.1 核心SIP架构与角色 (High-Level Architecture & Roles)

* **服务分离是最佳实践**：SIP 服务器（处理实时信令）和文件服务器（如存储录音的 HTTPS 服务）应作为**独立的服务**部署。这能确保资源隔离、独立伸缩、增强安全性和简化维护，避免文件传输的高 I/O 和带宽消耗影响到对延迟敏感的 SIP 核心业务。

* **SIP 服务器角色的区分**：一个“SIP服务器”可以是多种角色的组合。最关键的架构选择是在 **Proxy** 和 **B2BUA** 之间：
    * **代理 (Proxy)**：轻量级的**信令路由器**。它的职责是高效、智能地转发消息，但不深入干预通话内容。
    * **B2BUA (Back-to-Back User Agent)**：重量级的**通话控制器**。它完全终结并重新发起呼叫，能完全控制信令和媒体流，用于实现 SBC（会话边界控制器）、IP-PBX、媒体转码、WebRTC 网关等复杂功能。

* **客户端角色 (Client Role)**：客户端应始终被实现为一个标准的**用户代理 (User Agent, UA)**，比如使用 `sofia-sip` 里的 `nua` 接口。将其设计为 B2BUA 是不符合逻辑的。

6.2 代理服务器的“状态”精解 (Understanding "State" in a Proxy)

这是我们讨论的核心。一个代理的“有状态”与否，直接决定了其功能和性能。

* **有状态代理 (Stateful Proxy)**：**事实上的工业标准**。
    * 它所谓的“状态”是**事务状态 (Transaction State)**。
    * 它**只在短暂的事务期间**（比如一个 `INVITE` 从发出到收到最终响应的几秒内）保存状态，用于处理重传、分叉（Forking）和响应匹配。
    * 事务结束后，状态**立即被销毁**，以释放资源。
    * 这是它能够与注册（Registrar）、Presence 等服务联动，实现智能路由的基础。

* **无状态代理 (Stateless Proxy)**：
    * **“转发即忘”**，不保存任何状态。
    * 性能极高，但功能极其有限，不可靠且无法进行智能路由。
    * 几乎只用于特定场景下的高速负载均衡。

6.3 SIP协议的关键机制 (Key Protocol Mechanisms)

我们探讨了几个让 SIP 协议如此强大和灵活的底层机制：

* **事务 (Transaction) vs. 对话 (Dialog)**：
    * **事务**是短暂的“一问一答”，是状态的基本单元。
    * **对话**是长期的“一通完整通话”，代表了两个端点间的稳定关系。
    * **有状态代理关心事务，而终端（UA）和B2BUA关心对话。** 这个区别是理解 SIP 状态管理的关键。

* **状态的生命周期 —— 虽然有状态，但存续时间不长**：
    * 您最后的总结非常到位！这正是 SIP 代理服务器能够实现高性能和高并发的核心秘诀。它**避免了为数以万计的通话（对话）维持长期状态**，极大地提高了系统的可伸缩性和稳定性。

* **路由状态的“去中心化” (`Record-Route` & `Route`)**：
    * 这是 SIP 设计最优雅的部分之一。在通话建立时，代理通过 `Record-Route` 头部将自己的地址“印”在信令路径上。
    * 通话双方的终端（UA）会保存这个路径，形成**路由集 (Route Set)**。
    * 在后续的请求中（如 `BYE`），终端会将这个路由集填入 `Route` 头部，主动引导请求按原路返回。
    * **这解释了为什么代理服务器重启后，已建立的通话依然可以正常结束**。因为路由信息已经不在服务器上，而在终端里了。服务器只需根据每个新请求里的 `Route` 头部进行无状态的路由决策即可。

* **安全传输 (Secure Transport)**：
    * 对于浏览器客户端，可以通过 **WSS (WebSocket Secure)** 协议来加密 SIP 信令，其安全性与 HTTPS 相当。`sofia-sip` 提供了对 WSS 的支持。
    * 对于媒体流，则使用 **SRTP** 进行加密。

6.4 通话建立后，服务器离线，通话一方挂机

对方无法获得挂机信息，缺省需要`64*T1=32`秒超时后才可以清除挂机
`sofia-sip` 可以通过修改超时参数或者增加额外心跳处理

可以考虑：增加配置，

答案是：**默认情况下，即使您确定 Alice 和 Bob 之间网络层可以直达，挂机（`BYE`）请求仍然必须通过代理服务器。** 您不能简单地忽略代理直接发送给对方。

原因在于 SIP 是一个应用层协议，它的路由规则由其自身头部（Headers）的“契约”来决定，而不仅仅是底层的 IP 网络可达性。

-----

### 为什么不能绕过代理？核心机制：`Record-Route` 和 `Route`

我们再回顾一下这个关键机制：

1.  **通话建立时的“契约”**:

      * 当 Alice 的 `INVITE` 请求经过代理服务器时，代理为了能在后续的通话中保持控制（用于计费、统计、策略执行、提供增值服务等），会在 `INVITE` 中插入一个 `Record-Route` 头部，写上自己的地址。
      * 这个动作相当于代理在说：“**这通电话后面的所有信令，都必须从我这里过！**”
      * 当通话建立后，Alice 和 Bob 的客户端都会保存这个包含了代理地址的**路由集（Route Set）**。这是一个在通话期间必须遵守的“契约”。

2.  **挂断时履行“契约”**:

      * 当 Alice 挂断时，她的客户端会查找当前通话的路由集。
      * 它发现路由集里有代理的地址，于是它**必须**将这个地址填入 `BYE` 请求的 `Route` 头部。
      * 因此，`BYE` 的第一站被强制发往代理服务器，而不是直接发往 Bob。

**如果您绕过了这个规则，直接将 `BYE` 发给 Bob，会发生什么？**

  * **协议违规**：您的客户端将不遵循 RFC 3261 的标准。
  * **状态不一致**：代理服务器将永远不会收到 `BYE` 请求。在它看来，这通电话可能还一直持续着。这会导致计费错误、并发许可长时间被占用、通话统计不准确等一系列严重问题。

-----

### 如何实现您设想的“直达”挂机？

虽然默认行为是必须经过代理，但 SIP 协议也提供了实现“直达”通信的灵活性。关键在于**代理服务器在通话建立时的选择**。

要实现 `BYE` 的直达，代理服务器必须在处理最初的 `INVITE` 请求时，**决定不将自己加入到后续的信令路径中**。

它是如何做到的呢？**通过不添加 `Record-Route` 头部。**

我们来看一下这种流程：

1.  **通话建立时（代理选择“放手”）**:

      * Alice 发送 `INVITE` 到代理。
      * 代理收到 `INVITE`，它执行了认证、查询了 Bob 的地址，然后将 `INVITE` 转发给 Bob。但是，这一次它**没有**在 `INVITE` 中添加 `Record-Route` 头部。
      * `200 OK` 响应原路返回，同样不包含 `Record-Route` 头部。

2.  **对话建立**:

      * 通话建立后，Alice 和 Bob 的客户端检查信令，发现没有任何 `Record-Route` 记录。因此，它们为这个通话建立的**路由集是空的**。
      * 此时，双方后续通信的唯一依据是对方在 `INVITE` 和 `200 OK` 中提供的 `Contact` 头部地址。`Contact` 头部告诉对方：“这是我的直接联系地址”。

3.  **挂断时（直达）**:

      * Alice 挂断电话。
      * 她的客户端查找当前通话的路由集，发现是空的。
      * 于是，它直接将 Bob 的 `Contact` 地址作为 `BYE` 请求的 Request-URI，将 `BYE` **直接发送给 Bob 的 IP 地址**。
      * 此时，只要网络上可以直达，`BYE` 就会成功，并且完全绕过了代理。

-----

### 总结与权衡

| 路由模式 | 优点 | 缺点 |
| :--- | :--- | :--- |
| **代理在路径中 (默认)**\<br\>*(Proxy adds `Record-Route`)* | 1. **完全控制**：可计费、可录音、可统计。\<br\>2. **拓扑隐藏**：隐藏了端点的真实网络位置。\<br\>3. **NAT 穿透**：可以帮助处理复杂的 NAT 问题。\<br\>4. **功能丰富**：可以提供中途通话服务。 | 1. **单点故障**：代理离线会影响通话（如我们之前讨论的32秒超时）。\<br\>2. **性能瓶颈**：所有信令都经过代理，会增加其负载。 |
| **代理不在路径中**\<br\>*(Proxy does NOT add `Record-Route`)* | 1. **高可用性**：通话建立后，不受代理服务器故障影响。\<br\>2. **性能高**：信令直达，减轻代理压力。\<br\>3. **低延迟**：信令路径最短。 | 1. **失去控制**：代理无法再管理这通电话。\<br\>2. **暴露拓扑**：端点必须知道对方的直接地址。\<br\>3. **NAT 问题**：要求端点之间必须网络可达，NAT 场景下很难实现。 |

**结论**：

您的想法是完全可能的，但这取决于一个**架构决策**。这个决策需要在**通话建立时**由代理服务器做出。

  * 如果希望代理能持续管理和控制通话，就必须使用 `Record-Route`，后续的 `BYE` 也必须经过代理。
  * 如果只是想让代理扮演一个“介绍人”的角色，通话建立后就“功成身退”，那么代理就不能使用 `Record-Route`，这样后续的 `BYE` 就可以直达。

在绝大多数商业和运营商环境中，为了控制和管理，都会选择第一种模式。
我的系统决定改该，缺省选择第二种模式，但可配置为第一种模式

6.5 RTP的NAT考量

您提出了一个非常关键的问题，同时也触及了一个常见的误区。我们来详细拆解一下。

首先，需要澄清一点：代理服务器通过 `Record-Route` 留在信令路径中，主要解决的是 **SIP信令** 的NAT穿透问题，确保 `BYE`, Re-`INVITE` 等后续请求能正确路由回处于NAT后的客户端。

但它**本身不解决 RTP 媒体流的 NAT 穿透问题**。

RTP流的NAT穿透是SIP通信中最复杂、最核心的挑战之一，需要专门的技术来解决。

### RTP流面临的NAT问题

1.  **私有地址问题**：位于NAT后的客户端（Alice），在生成SDP（Session Description Protocol，用于描述媒体会话）时，默认会填入自己的**私有IP地址**（例如 `192.168.1.100`）。
2.  **地址不可达**：当这个SDP通过信令发送给公网上的另一个客户端（Bob）时，Bob无法将RTP包发送到 `192.168.1.100` 这个地址，因为这是个私有地址，在公网上不可路由。
3.  **NAT的限制**：即使Alice的客户端知道了自己的公网IP地址，大多数家用或企业NAT设备默认会阻止未经请求的外部数据包进入内部网络。

因此，必须采用特殊技术来“打穿”NAT，让RTP媒体流能够双向互通。主要有两大类方法：**客户端技术（ICE/STUN/TURN）** 和 **服务器端技术（媒体代理）**。

---

### 方案一：客户端技术 (ICE / STUN / TURN)

这是目前最主流、最现代化的解决方案，尤其在WebRTC中被广泛采用。它将解决NAT问题的“智能”放在客户端。

#### 1. STUN (Session Traversal Utilities for NAT) - “我是谁？”

* **作用**：STUN是一个简单的协议，用来帮助客户端发现自己的**公网IP地址和端口**（被称为“服务器反射地址 Server-Reflexive Address”）。
* **流程**：
    1.  客户端向公网上的一个STUN服务器发送一个请求。
    2.  STUN服务器收到请求后，会看到该请求的源IP和端口（这就是客户端经过NAT转换后的公网地址和端口）。
    3.  STUN服务器将这个公网地址和端口作为响应发回给客户端。
    4.  客户端拿到这个公网地址后，就可以填入到SDP中，而不是填自己的私有地址。
* **局限**：STUN对某些类型的NAT（如对称NAT，Symmetric NAT）无效。

#### 2. TURN (Traversal Using Relays around NAT) - “请帮我转发”

* **作用**：当STUN失败时，TURN作为最终的“救火队员”出场。它是一台中继服务器。
* **流程**：
    1.  客户端在TURN服务器上申请一个中继地址。
    2.  客户端将自己的RTP流发送给TURN服务器的这个中继地址。
    3.  同时，它告诉对方（通过SDP），请将RTP流也发往我在TURN服务器上的这个中继地址。
    4.  TURN服务器收到一方的RTP包后，将其**中继（Relay）**给另一方。
* **特点**：通话双方的媒体流都经过服务器中转，不再是P2P（点对点）。这能保证100%的连通性，但会**消耗服务器的大量带宽**，并增加通话延迟，所以通常作为最后的备选方案。

#### 3. ICE (Interactive Connectivity Establishment) - “智能路径选择大师”

* **作用**：ICE不是一个独立的协议，而是一个框架（Framework），它**智能地协调STUN和TURN**来寻找最佳的通信路径。
* **流程**：
    1.  **收集候选地址 (Candidate Gathering)**：通话前，每个客户端都会收集所有可能的接收地址：
        * 自己的**私有IP地址**（主机候选者 Host Candidate）。
        * 通过STUN发现的**公网IP地址**（服务器反射候选者 Server-Reflexive Candidate）。
        * 从TURN服务器获取的**中继地址**（中继候选者 Relay Candidate）。
    2.  **交换候选地址**：双方通过SDP将自己收集到的所有候选地址列表交换给对方。
    3.  **连通性检查 (Connectivity Checks)**：双方拿到对方的地址列表后，会两两配对，尝试发送STUN请求进行“打孔”和连通性测试。
    4.  **选择最佳路径**：ICE会根据测试结果，优先选择最理想的路径：
        * **优先级1**: Host-to-Host （私网内直接通信，延迟最低）。
        * **优先级2**: ServerReflexive-to-ServerReflexive （P2P穿透NAT，效率高）。
        * **优先级3**: Host-to-ServerReflexive （一方在公网，一方在NAT后）。
        * **优先级4**: Relay-to-Relay （通过TURN服务器中继，作为最后保障）。

---

### 方案二：服务器端技术 - 媒体代理 (Media Proxy / RTP Proxy)

这是一种更传统的、由服务器完全掌控的解决方案。通常由一个 **B2BUA** 或 **SBC (Session Border Controller)** 来实现。

* **作用**：服务器作为通话双方的“中间人”，让所有RTP流都流经自己。
* **流程**：
    1.  Alice发起呼叫，在SDP中描述了她期望接收媒体的地址和端口。
    2.  SBC收到后，**修改SDP**，将接收地址和端口换成SBC自己的公网地址和端口，然后才转发给Bob。
    3.  Bob应答时，SBC同样会修改Bob的SDP，换成SBC自己的地址，再转发给Alice。
    4.  最终结果是，Alice和Bob都以为自己在和对方直接通话，但实际上他们的RTP流都发往了SBC。SBC负责在中间进行媒体的接收和转发。
* **优点**：
    * **可靠性极高**：能解决几乎所有类型的NAT问题。
    * **安全性好**：完全隐藏了内部网络的拓扑。
* **缺点**：
    * **资源消耗大**：所有通话的媒体流都消耗服务器的CPU和带宽。
    * **延迟增加**：媒体流多了一跳，延迟必然增加。

### 总结对比

| 特性 | ICE (STUN/TURN) 客户端方案 | 媒体代理 (SBC/B2BUA) 服务器方案 |
| :--- | :--- | :--- |
| **实现位置** | 客户端（UA） | 服务器（SBC, B2BUA） |
| **媒体路径** | 尽可能 P2P（点对点） | 始终通过服务器中继 |
| **资源效率** | 更高（如果P2P成功） | 更低（始终消耗服务器带宽） |
| **可靠性** | 依赖TURN作为最终保障 | 非常高 |
| **延迟** | 更低（如果P2P成功） | 更高 |
| **适用场景** | WebRTC, 现代软电话 | 运营商网络, 企业边界控制, 需要强管控的场景 |

### `sofia-sip` 在其中的角色

* `sofia-sip` 本身是一个纯粹的 **SIP 协议栈**，其核心是处理信令。它**不包含一个完整的媒体引擎或ICE实现**。
* 在您提供的源代码中，`libsofia-sip-ua/stun/` 目录下包含了STUN协议相关的基础工具和解析代码。这表明 `sofia-sip` 能够辅助应用程序去实现NAT穿透，但它本身不是一个开箱即用的ICE代理。
* 要用 `sofia-sip` 开发一个支持NAT穿透的客户端，您需要**将 `sofia-sip` 与一个实现了ICE的媒体库（如 `libnice`, `pjproject` 的 `pjmedia` 等）进行集成**。`sofia-sip` 负责信令部分的SDP交换，媒体库负责ICE流程和RTP传输。